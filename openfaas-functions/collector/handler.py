import os
import sys
import json
import time
import uuid
import redis
from datetime import datetime
from zoneinfo import ZoneInfo

redisClient = None
backoff_factor = 2
retries = 10

def init_redis_client():
    """
    Initializes a Redis client with fallback values.
    Works for both local and in-cluster use.
    """
    host = os.getenv("REDIS_HOSTNAME", "redis-master.redis.svc.cluster.local")
    port = int(os.getenv("REDIS_PORT", 6379))

    try:
        return redis.Redis(host=host, port=port, decode_responses=True)
    except redis.exceptions.RedisError as e:
        print(f"[ERROR] Redis initialization failed: {e}", file=sys.stderr)
        sys.exit(1)

def deadline_for_matrix(n: int, coeff: float = 2.5e-7, cap: int = 30, floor: int = 1) -> int:
    """
    Analytic deadline (seconds) for an nxn matrix multiplication.

    deadline = min( max(floor, coeff · n³), cap )   # seconds

    • n       - size of the matrix (n x n).
    • coeff   - tunes how many seconds per floating-point operation.
    • cap     - hard upper bound so the system never waits 'forever'.
    • floor   - hard lower bound so the system never waits less than 1 second.
    """
    return int(min(max(floor, coeff * n**3), cap))

def parse_request_body(event):
    try:
        body = json.loads(event.body)
        if not body:
            raise ValueError("Empty request body")
        return body
    except (json.JSONDecodeError, TypeError, ValueError) as e:
        raise ValueError(f"ERROR: {e} - Raw Body: {str(event.body)[:512]}", file=sys.stderr)

def safe_redis_call(func):
    try:
        return func()
    except redis.exceptions.ConnectionError as e:
        print(f"[ERROR] Redis connection error: {e}. Retrying...")
        time.sleep(1)
        global redisClient
        redisClient = init_redis_client()
        return func()

def fetch_control_message(redis_client, control_queue):
    try:
        control_raw = safe_redis_call(lambda: redis_client.rpop(control_queue))
        return json.loads(control_raw) if control_raw else None
    except Exception as e:
        raise ValueError(f"[ERROR] Failed to parse control message: {e}")

def extract_result(raw_result):
    try:
        result = json.loads(raw_result)
        if not isinstance(result, dict):
            raise ValueError("Result is not a JSON object")

        required_keys = ['task_id', 'task_gen_timestamp', 'task_deadline', 'task_work_timestamp']
        if not all(k in result for k in required_keys):
            raise ValueError("Result missing required keys")

        deadline = result.get("task_deadline")
        work_ts = result.get("task_work_timestamp")
        gen_ts = result.get("task_gen_timestamp")
        task_id = result.get("task_id")
        print(f"[DEBUG] Extracted result for task {task_id}")
        now = time.time()
        deadline_met = (now - gen_ts) <= deadline

        return {
            "task_id": task_id,
            "task_application": result.get("task_application"),
            "task_gen_timestamp": gen_ts,
            "task_result_data": result.get("task_result_data"),
            "task_emit_time": result.get("task_emit_time"),
            "task_emit_timestamp" : result.get("task_emit_timestamp"),
            "task_deadline": deadline,
            "task_collect_time": now - work_ts,
            "task_collect_timestamp": now,
            "task_output_size": result.get("task_output_size"),
            "task_work_time": result.get("task_work_time"),
            "task_work_timestamp": work_ts,
            "task_QoS": deadline_met
        }
    except (json.JSONDecodeError, ValueError) as e:
        raise ValueError(f"ERROR: Malformed result: {e} - Raw: {raw_result[:256]}", file=sys.stderr)

def feedback_task_generation(result, redisClient, input_q, body):
    feedback_task = {
        "task_id": str(uuid.uuid4()),
        "task_gen_timestamp": time.time(),
        "task_application": result["task_application"],
        "task_data": None,  # Actual data will be generated by workers
        "task_data_size": result["task_output_size"][0],
        "task_deadline": deadline_for_matrix(result["task_output_size"][0])  # seconds
    }
    safe_redis_call(lambda: redisClient.lpush(input_q, json.dumps(feedback_task)))
    print(f"[INFO] Feedback task generated: {feedback_task['task_id']} for result {result['task_id']}")

def send_start_signal(redis_client, start_queue, pod_name, start_timestamp):
    """
    Sends a start signal to start queue.
    """
    start_signal = {
        "type": "START",
        "action": "SYNC",
        "start_timestamp": start_timestamp.strftime('%Y-%m-%d %H:%M:%S %Z'),
        "pod_name": pod_name,
        "message": f"{pod_name} is ready to start processing tasks."
    }

    safe_redis_call(lambda: redisClient.lpush(start_queue, json.dumps(start_signal)))
    print(f"[INFO] {pod_name} sent START signal: {start_signal}")

def handle(event, context):
    now = datetime.now(ZoneInfo("Europe/Rome"))
    pod_name = os.environ.get("HOSTNAME")
    print(f"\n[Collector] Invoked at {now.strftime('%Y-%m-%d %H:%M:%S %Z')} on pod {pod_name}")
    num_results = 0
    global redisClient
    if redisClient is None:
        try:
            redisClient = init_redis_client()
        except redis.exceptions.ConnectionError as e:
            print(f"[CRITICAL] Redis connection failed: {e}", file=sys.stderr)
            return {"statusCode": 500, "body": f"Redis connection failed: {e}"}

    body = parse_request_body(event)
    if not body:
        return {"statusCode": 400, "body": "Invalid JSON in request body."}

    result_q, output_q = body.get('result_queue_name'), body.get("output_queue_name")
    input_q, feedback_flag = body.get('input_queue_name'), body.get("collector_feedback_flag")
    control_syn_q, start_q = body.get('collector_control_syn_queue_name'), body.get('collector_start_queue_name')
    print(f"[DEBUG] Collector received body: {body}")

    if not all([input_q, result_q, output_q, start_q, feedback_flag is not None]):
        return {"statusCode": 400, "body": "Missing required fields in request body."}

    # send start signal to start queue
    send_start_signal(redisClient, start_q, pod_name, now)

    previous_iteration_start = None
    attempt = 0

    while True:
        print("------------------------------")
        iteration_start = time.time()
        if previous_iteration_start:
            print(f"[INFO] Iteration time: {iteration_start - previous_iteration_start:.2f} sec")
        previous_iteration_start = iteration_start

        try:
            control_msg = fetch_control_message(redisClient, control_syn_q)
            if control_msg and control_msg.get("action") == "SYN" and control_msg.get("type") == "TEMINATE":
                print(f"[INFO] Received TERMINATE control message: {control_msg}")
                return {
                    "statusCode": 200,
                    "body": f"Collector pod {pod_name} acknowledged termination."
                }

            raw_result = safe_redis_call(lambda: redisClient.rpop(result_q))

            if not raw_result:
                attempt += 1
                sleep_time = backoff_factor ** attempt
                print(f"[INFO] No result found in '{result_q}' for {attempt} tries, waiting {sleep_time} seconds...")
                time.sleep(sleep_time)
                if attempt >= retries:
                    print("[WARNING] No results found for a long time, exiting collector.")
                    return {
                        "statusCode": 200,
                        "body": f"Collector pod {pod_name} exited due to inactivity."
                    }
                continue
            else:
                attempt = 0
                now = datetime.now(ZoneInfo("Europe/Rome"))
                print(f"\n[Collector] got result at {now.strftime('%Y-%m-%d %H:%M:%S %Z')} on pod {pod_name}")
                # Fetch and parse results
                result = extract_result(raw_result)
                num_results += 1
                safe_redis_call(lambda: redisClient.lpush(output_q, json.dumps(result)))

                # Feedback task generation
                if feedback_flag and input_q:
                    print(f"[INFO] Feedback : Generating task from result {result['task_id']}")
                    feedback_task_generation(result, redisClient, input_q, body)

                print(f"[Collector] Processed {num_results} results from '{result_q}' and pushed to '{output_q}'")

        except Exception as e:
            print(f"ERROR: Unexpected error: {e}", file=sys.stderr)
            return {
                "statusCode": 500,
                "body": f"Unexpected error: {e}"
            }
    print(f"[Collector] Collector processed {num_results} results.")

    return {
        "statusCode": 200,
        "body": f"Processed result from '{result_q}' and pushed to '{output_q}'."
    }
